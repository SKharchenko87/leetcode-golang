package p1488

import "sort"

// ToDo
// avoidFlood решает задачу "Избежать наводнения в городе" (LeetCode 1488).
// Используется жадная стратегия с отслеживанием последнего дождя и
// бинарным поиском по доступным сухим дням.
func avoidFlood(rains []int) []int {
	N := len(rains)
	ans := make([]int, N)

	// lastRain: Карта для хранения последнего индекса дня, когда озеро стало полным.
	// Ключ: номер озера, Значение: индекс дня (int).
	lastRain := make(map[int]int)

	// dryDays: Отсортированный слайс индексов дней, когда можно осушать (rains[i] == 0).
	// Мы будем использовать бинарный поиск (sort.SearchInts) по этому слайсу.
	dryDays := make([]int, 0)

	// Проходим по всем дням
	for i := 0; i < N; i++ {
		lakeID := rains[i]

		if lakeID > 0 {
			// День дождя (rains[i] > 0)
			ans[i] = -1 // Согласно условию, в день дождя ans[i] = -1

			// 1. Проверяем, было ли это озеро уже полным
			lastRainDay, isFull := lastRain[lakeID]

			if isFull {
				// Озеро полное. Наводнение неизбежно, если мы не осушим его раньше.

				// 2. Жадный выбор: Нам нужно найти самый ранний доступный сухой день 'k',
				// который произошел ПОСЛЕ последнего наполнения озера (k > lastRainDay).

				// Используем бинарный поиск (sort.SearchInts) по отсортированному dryDays,
				// чтобы найти индекс первого сухого дня, который удовлетворяет условию k > lastRainDay.
				// sort.SearchInts возвращает индекс, куда нужно вставить lastRainDay,
				// чтобы массив остался отсортированным. Это и есть индекс первого элемента > lastRainDay.
				idx := sort.SearchInts(dryDays, lastRainDay)

				if idx == len(dryDays) {
					// Это означает, что все доступные сухие дни (если они есть)
					// произошли ДО последнего наполнения озера (или dryDays пуст).
					// Наводнения избежать невозможно.
					return []int{}
				}

				// 3. Найдена оптимальная дата осушения: dryDays[idx]
				dryDayIndex := dryDays[idx]

				// 4. Назначаем осушение: В этот сухой день (dryDayIndex) мы осушим LakeID.
				ans[dryDayIndex] = lakeID

				// 5. Удаляем использованный сухой день из пула доступных dryDays.
				// Создаем новый слайс, исключая элемент с индексом idx.
				dryDays = append(dryDays[:idx], dryDays[idx+1:]...)
			}

			// 6. Обновляем информацию: Озеро lakeID теперь полное, и это произошло в день 'i'.
			lastRain[lakeID] = i

		} else {
			// День осушения (rains[i] == 0)
			// Мы просто сохраняем индекс этого дня в пуле, не назначая ему озеро пока.
			// По условию задачи, если день осушения не был использован для предотвращения наводнения,
			// мы можем осушить любое озеро. По умолчанию в конце мы назначим ему 1.
			dryDays = append(dryDays, i)
			ans[i] = 1 // Временно ставим 1.
		}
	}

	// 7. Очистка оставшихся сухих дней:
	// Те сухие дни, которые не были использованы для предотвращения наводнения,
	// должны быть заполнены любым номером озера > 0.
	// Мы уже назначили им 1 во время прохода, так что можно оставить их как есть.
	// Но если бы мы не назначали 1 заранее (ans[i]=1), мы бы сделали это здесь.

	return ans
}
